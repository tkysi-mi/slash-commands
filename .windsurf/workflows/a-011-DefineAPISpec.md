---
description: データモデルと画面設計からAPI仕様を定義し、認証方式、エンドポイント一覧、共通レスポンス形式を明確化するワークフロー
auto_execution_mode: 1
---

# /a-011-DefineAPISpec

## 目的

- データモデルと画面設計を基に、API仕様の基本設計を定義する。
- API設計スタイル（REST、GraphQL、gRPC、tRPC）を決定する。
- 認証・認可方式を明確化する。
- エンドポイント一覧（メソッド、パス、説明、認証要否）を定義する。
- 共通レスポンス形式（成功/エラー）を定義する。
- フロントエンド・バックエンド間のAPI契約を明確にする。

## 前提

- `docs/project/04-design/01-tech-stack.md` が作成されていること（APIスタイル選定済み）
- `docs/project/04-design/04-data-model.md` が作成されていること（推奨）
- `docs/project/04-design/03-screen-design.md` が作成されていること（推奨）
- `.windsurf/templates/project/04-design/05-api-spec.md` テンプレートが最新状態であること

## 重要な前提：詳細な仕様の管理

**このドキュメントは高レベルな設計のみを記録**します。詳細な実装仕様は以下のツールで管理：

- **OpenAPI/Swagger**: リクエスト/レスポンスの詳細なJSONスキーマ、バリデーションルール
- **コード**: エラーコード定義、バリデーター、エラーハンドラー
- **GraphQL Schema**: GraphQL を使用する場合のスキーマ定義
- **Protobuf**: gRPC を使用する場合のメッセージ定義

このドキュメントでは、API全体の構造と基本的な契約のみを記載します。

## 手順

### 1. ドキュメントと前提条件の確認

- 関連ドキュメントを読み込む：
  - `@docs/project/04-design/01-tech-stack.md`（バックエンド技術、APIスタイル）
  - `@docs/project/04-design/04-data-model.md`（エンティティ一覧）
  - `@docs/project/04-design/03-screen-design.md`（画面で必要なデータ操作）

- ドキュメントが不足している場合：
  - 「技術スタックまたはデータモデルが定義されていません。最低限、APIスタイル（REST、GraphQLなど）とデータモデルが必要です。」
  - 利用可能なドキュメントの範囲でAPI仕様を作成することをユーザーに確認

### 2. API設計スタイルの確認と決定

#### 2.1. 技術スタックからの確認

- 技術スタックドキュメントで選定されたAPIスタイルを確認：
  - **REST API**: 最も一般的、HTTPメソッドとリソースベース
  - **GraphQL**: 柔軟なクエリ、フロントエンドが必要なデータだけ取得
  - **gRPC**: 高パフォーマンス、バイナリプロトコル、マイクロサービス向き
  - **tRPC**: TypeScript環境でのエンドツーエンド型安全性
  - **ハイブリッド**: 複数のスタイルを併用（例：メインはREST、リアルタイム通信はGraphQL Subscription）

#### 2.2. APIスタイルの特徴確認

選定されたスタイルに応じて、以下を確認：

**REST API の場合**:
- リソース指向設計
- HTTPメソッド（GET、POST、PUT、PATCH、DELETE）
- ステータスコード（200、201、400、404、500など）
- エンドポイントはリソースベース（`/api/users`, `/api/orders`）

**GraphQL の場合**:
- スキーマベース設計
- Query（読み取り）、Mutation（書き込み）、Subscription（リアルタイム）
- 単一エンドポイント（通常 `/graphql`）
- クライアントが必要なフィールドを指定

**gRPC の場合**:
- Protobuf（Protocol Buffers）でメッセージ定義
- サービス定義（RPC メソッド）
- 高速バイナリプロトコル

**tRPC の場合**:
- TypeScriptの型定義から自動的にAPIクライアント生成
- エンドツーエンドの型安全性
- サーバーとクライアントで型を共有

**このワークフローの対象**:
- 主に **REST API** を対象とする
- GraphQL、gRPC、tRPC の場合は、基本的な設計方針とエンドポイント/スキーマの概要を記録

### 3. 認証・認可方式の定義

#### 3.1. 認証方式の確認

- 技術スタックドキュメントで選定された認証方式を確認：
  - **JWT (JSON Web Token)**: ステートレス、マイクロサービス向き
  - **OAuth 2.0**: サードパーティ認証、権限委譲
  - **API Key**: シンプル、内部API向き
  - **Session Cookie**: ステートフル、Webアプリ向き
  - **外部認証プロバイダー**: Auth0、Clerk、Supabase Auth など

#### 3.2. 認証方式の詳細定義

選定された認証方式について、以下をヒアリング：

**JWT の場合**:

**質問1: トークンの種類**
- 「アクセストークンとリフレッシュトークンの両方を使用しますか？」
  - アクセストークンのみ
  - アクセストークン + リフレッシュトークン（推奨）

**質問2: トークン有効期限**
- 「各トークンの有効期限は？」
  - アクセストークン：15分〜1時間（推奨：15分）
  - リフレッシュトークン：7日〜30日（推奨：30日）

**質問3: トークン格納場所**
- 「フロントエンドでトークンをどこに保存しますか？」
  - localStorage（XSSリスクあり）
  - sessionStorage
  - HttpOnly Cookie（推奨：XSS対策）
  - メモリのみ（最もセキュア、リロード時に再認証必要）

**質問4: トークン形式**
- 「トークンはどのヘッダーで送信しますか？」
  - `Authorization: Bearer {token}`（標準）
  - カスタムヘッダー（例：`X-Auth-Token`）

**OAuth 2.0 の場合**:

**質問1: フロー**
- 「OAuth 2.0 のどのフローを使用しますか？」
  - Authorization Code Flow（推奨：Webアプリ）
  - Authorization Code Flow with PKCE（推奨：SPA、モバイル）
  - Implicit Flow（非推奨）
  - Client Credentials Flow（サーバー間通信）

**質問2: スコープ**
- 「権限スコープをどのように定義しますか？」
  - 例：`read`, `write`, `admin`
  - 例：`users:read`, `users:write`, `orders:read`

**Session Cookie の場合**:

**質問1: セッション保存先**
- 「セッション情報をどこに保存しますか？」
  - インメモリ（開発環境）
  - Redis（推奨：本番環境）
  - データベース

**質問2: Cookie設定**
- 「Cookieの設定は？」
  - HttpOnly: true（XSS対策）
  - Secure: true（HTTPS通信のみ）
  - SameSite: Strict または Lax（CSRF対策）

#### 3.3. 認証フローの定義

- 「基本的な認証フローを確認します。」

**JWT（アクセストークン + リフレッシュトークン）の例**:
1. POST `/api/auth/login` でログイン
2. アクセストークンとリフレッシュトークンを取得
3. 以降のリクエストで `Authorization: Bearer {accessToken}` ヘッダーに含める
4. アクセストークン期限切れ時は POST `/api/auth/refresh` でリフレッシュ
5. リフレッシュトークンも期限切れの場合は再ログイン

#### 3.4. 認可（権限管理）

**質問5: ロールベースアクセス制御（RBAC）**
- 「ロールベースの権限管理を使用しますか？」
  - はい：ロール一覧を定義（例：admin、user、guest）
  - いいえ：権限スコープのみで管理

**質問6: リソースレベルの権限**
- 「リソースごとに権限を細かく制御しますか？」
  - 例：「自分の注文のみ閲覧可能」「自分のプロフィールのみ編集可能」

### 4. エンドポイントの抽出と定義

#### 4.1. データモデルからのエンドポイント抽出

データモデルの各エンティティについて、標準的なCRUD操作のエンドポイントを抽出：

**標準的なRESTful エンドポイント**:
- `GET /api/{resource}` - 一覧取得
- `GET /api/{resource}/{id}` - 詳細取得
- `POST /api/{resource}` - 作成
- `PUT /api/{resource}/{id}` - 更新（完全置換）
- `PATCH /api/{resource}/{id}` - 更新（部分更新）
- `DELETE /api/{resource}/{id}` - 削除

例：
- `GET /api/users` - ユーザー一覧取得
- `GET /api/users/{id}` - ユーザー詳細取得
- `POST /api/users` - ユーザー作成
- `PUT /api/users/{id}` - ユーザー更新
- `DELETE /api/{resource}/{id}` - ユーザー削除

#### 4.2. 画面設計からの追加エンドポイント抽出

画面設計で必要な操作を確認し、CRUD以外のエンドポイントを抽出：

- アクション型エンドポイント：
  - `POST /api/orders/{id}/cancel` - 注文キャンセル
  - `POST /api/users/{id}/reset-password` - パスワードリセット
  - `POST /api/products/{id}/publish` - 商品公開

- 検索・フィルタリング：
  - `GET /api/users?search=keyword&role=admin`
  - `GET /api/orders?status=pending&user_id=123`

- 関連リソース：
  - `GET /api/users/{userId}/orders` - 特定ユーザーの注文一覧
  - `GET /api/orders/{orderId}/items` - 特定注文の明細一覧

#### 4.3. 認証関連エンドポイント

**質問1: 認証エンドポイント**
- 認証方式に応じて、以下のエンドポイントを定義：

**JWT の場合**:
- `POST /api/auth/login` - ログイン
- `POST /api/auth/logout` - ログアウト
- `POST /api/auth/refresh` - トークンリフレッシュ
- `POST /api/auth/register` - ユーザー登録（該当する場合）
- `POST /api/auth/forgot-password` - パスワード忘れ（該当する場合）

**OAuth 2.0 の場合**:
- `GET /api/auth/authorize` - 認可エンドポイント
- `POST /api/auth/token` - トークンエンドポイント
- `POST /api/auth/revoke` - トークン無効化

#### 4.4. 各エンドポイントの詳細定義

各エンドポイントについて、以下をヒアリング：

**質問1: エンドポイントの必要性**
- 「このエンドポイントは本当に必要ですか？」
- 過剰なエンドポイントを避ける

**質問2: HTTPメソッド**
- 「このエンドポイントのHTTPメソッドは？」
  - GET：読み取り（冪等性あり）
  - POST：作成、アクション（冪等性なし）
  - PUT：完全更新（冪等性あり）
  - PATCH：部分更新（冪等性あり）
  - DELETE：削除（冪等性あり）

**質問3: パス設計**
- 「パスの設計は適切ですか？」
- RESTful の原則：
  - リソース名は複数形（`/users` not `/user`）
  - 階層構造を表現（`/users/{userId}/orders`）
  - アクションはパスの最後に（`/orders/{id}/cancel`）

**質問4: 認証要否**
- 「このエンドポイントは認証が必要ですか？」
  - 必要：認証済みユーザーのみアクセス可能
  - 不要：未認証ユーザーもアクセス可能（公開エンドポイント）
  - オプション：認証があればより多くの情報を返す

**質問5: 必要な権限**
- 「このエンドポイントにアクセスするために必要な権限は？」
  - 例：read、write、admin
  - 例：本人のみ、管理者のみ

#### 4.5. ページネーション、ソート、フィルタリング

**質問6: 一覧取得エンドポイントのパラメータ**
- 「一覧取得エンドポイントでページネーション、ソート、フィルタリングを提供しますか？」

**ページネーション**:
- オフセットベース：`?limit=20&offset=0`
- カーソルベース：`?limit=20&cursor=abc123`
- ページ番号ベース：`?page=1&per_page=20`

**ソート**:
- `?sort=created_at&order=desc`
- `?sort=-created_at`（降順を `-` で表現）

**フィルタリング**:
- `?status=active&role=admin`
- `?search=keyword`

### 5. 共通レスポンス形式の定義

#### 5.1. 成功レスポンスの形式

**質問1: 成功レスポンスの構造**
- 「成功レスポンスの基本構造はどうしますか？」

**パターンA: データのみ**（シンプル）:
```json
{
  "id": 1,
  "name": "User Name"
}
```

**パターンB: ラップ形式**（推奨）:
```json
{
  "data": {
    "id": 1,
    "name": "User Name"
  }
}
```

**パターンC: ラップ形式 + メタデータ**（一覧取得向け）:
```json
{
  "data": [...],
  "meta": {
    "total": 100,
    "limit": 20,
    "offset": 0
  }
}
```

**質問2: タイムスタンプの形式**
- 「日時の形式は？」
  - ISO 8601形式（推奨）：`2024-01-01T00:00:00Z`
  - Unix timestamp（秒）：`1704067200`
  - Unix timestamp（ミリ秒）：`1704067200000`

**質問3: nullの扱い**
- 「nullフィールドをレスポンスに含めますか？」
  - 含める（明示的）：`{"field": null}`
  - 含めない（省略）：`{}`

#### 5.2. エラーレスポンスの形式

**質問4: エラーレスポンスの構造**
- 「エラーレスポンスの基本構造はどうしますか？」

**基本構造**（推奨）:
```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "Human-readable error message"
  }
}
```

**バリデーションエラーの場合**:
```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Validation failed",
    "details": [
      { "field": "email", "message": "Invalid email format" }
    ]
  }
}
```

**質問5: エラーコードの命名規則**
- 「エラーコードの命名規則は？」
  - UPPER_SNAKE_CASE（推奨）：`VALIDATION_ERROR`, `UNAUTHORIZED`
  - kebab-case：`validation-error`, `unauthorized`
  - カスタムコード：`ERR_001`, `ERR_002`

#### 5.3. HTTPステータスコードの定義

**質問6: 使用するHTTPステータスコード**
- 「プロジェクトで使用する主要なHTTPステータスコードを確認します。」

標準的なステータスコード：

| ステータスコード | 説明 | 使用場面 |
|----------------|------|---------|
| **200 OK** | 成功 | GET, PUT, PATCH の成功 |
| **201 Created** | リソース作成成功 | POST でのリソース作成成功 |
| **204 No Content** | 成功（レスポンスボディなし） | DELETE 成功時 |
| **400 Bad Request** | 不正なリクエスト | バリデーションエラー |
| **401 Unauthorized** | 認証エラー | トークン不正・期限切れ |
| **403 Forbidden** | 権限不足 | 認証済みだが権限不足 |
| **404 Not Found** | リソースが存在しない | 指定したIDのリソースが見つからない |
| **409 Conflict** | リソースの競合 | 既に存在するメールアドレスなど |
| **429 Too Many Requests** | レート制限超過 | リクエスト数が上限を超えた |
| **500 Internal Server Error** | サーバーエラー | サーバー内部エラー |

### 6. バージョニング戦略（オプション）

**質問7: APIバージョニング**
- 「APIのバージョニング戦略を定義しますか？」

**バージョニング方法**:
- **URL パス**: `/api/v1/users`, `/api/v2/users`
- **ヘッダー**: `Accept: application/vnd.api.v1+json`
- **クエリパラメータ**: `/api/users?version=1`
- **バージョニングしない**: 初期段階では不要、後で追加

### 7. レート制限（オプション）

**質問8: レート制限**
- 「APIのレート制限を設定しますか？」
  - 例：ユーザーごとに1時間あたり1000リクエスト
  - 例：IPアドレスごとに1分あたり60リクエスト

- レート制限の実装：
  - アプリケーションレベル（コード）
  - APIゲートウェイ（AWS API Gateway、Cloudflareなど）
  - Nginx、Redis

### 8. エンドポイント一覧の整理

#### 8.1. リソースごとにグループ化

抽出したエンドポイントをリソースごとにグループ化：

- **認証関連**（Auth）
- **ユーザー管理**（Users）
- **注文管理**（Orders）
- **商品管理**（Products）
- ...

#### 8.2. CRUD操作の整合性確認

- 各リソースでCRUD操作が揃っているか確認：
  - 一覧取得（GET）
  - 詳細取得（GET）
  - 作成（POST）
  - 更新（PUT/PATCH）
  - 削除（DELETE）

- 不足している操作がある場合：
  - 意図的か確認
  - 必要な場合は追加

### 9. ドキュメント作成

- 収集した情報を基に、`docs/project/04-design/05-api-spec.md` を作成

- テンプレートに従い、以下を記載：
  - **認証・認可**
    - 認証方法、トークン有効期限、トークン形式、権限スコープ
    - 認証フロー概要
  - **エンドポイント一覧**（リソースごとにテーブル形式）
    - メソッド、パス、説明、認証要否、ステータス（実装済み/未実装）
  - **共通レスポンス形式**
    - 成功レスポンス（基本構造、単一リソース例、リスト取得例）
    - エラーレスポンス（基本構造、バリデーションエラー例）
    - 主要なHTTPステータスコード
  - **バージョニング戦略**（オプション）
  - **レート制限**（オプション）
  - **OpenAPI/Swaggerへのリンク**（詳細仕様を管理する場合）
  - **メモ**（補足情報）

- **HTMLコメントは削除せず残す**

### 10. レビューと確認

- 作成したドキュメントをユーザーに提示：
  - 「API仕様ドキュメントが完成しました。内容を確認してください。」
  - 「すべての必要なエンドポイントが網羅されていますか？」
  - 「認証フローは明確ですか？」
  - 「レスポンス形式は一貫していますか？」

- 統計情報を表示：
  - エンドポイント総数
  - リソース別の内訳（認証: X個、ユーザー: X個、注文: X個...）
  - 認証必須エンドポイント数 / 公開エンドポイント数

### 11. 完成とコミット準備

- `docs/project/04-design/05-api-spec.md` が保存されたことを確認

- 次のステップを提案：
  - 「API仕様が完了しました。次は詳細なOpenAPI/Swagger仕様を作成しますか？」
  - または：「次はアーキテクチャ設計を定義しますか？（`/a-012-DefineArchitecture`）」

## 完了条件

- `docs/project/04-design/05-api-spec.md` が作成されている
- 以下のセクションがすべて記載されている：
  - 認証・認可（認証方法、トークン有効期限、権限スコープ、認証フロー）
  - エンドポイント一覧（メソッド、パス、説明、認証要否、ステータス）
  - 共通レスポンス形式（成功/エラー、HTTPステータスコード）
- 各エンドポイントについて以下が定義されている：
  - HTTPメソッド（GET、POST、PUT、PATCH、DELETE）
  - パス（RESTfulな設計）
  - 説明（1行）
  - 認証要否（必要/不要/オプション）
  - 必要な権限（該当する場合）
- 認証方式が明確に定義されている
- 共通レスポンス形式が統一されている
- データモデルの主要なエンティティに対応するエンドポイントが含まれている
- 画面設計で必要な操作に対応するエンドポイントが含まれている
- ユーザーが内容を確認し、承認している

## エスカレーション

- 技術スタックでAPIスタイルが選定されていない場合：
  - 「APIスタイル（REST、GraphQL、gRPCなど）が選定されていません。先に `/a-007-DefineTechStack` を実行してください。」

- データモデルが定義されていない場合：
  - 「データモデルが定義されていません。エンドポイントを網羅的に抽出できません。先に `/a-010-DefineDataModel` を実行してください。」
  - または：「画面設計から推測してエンドポイントを定義しますか？」

- エンドポイント設計がRESTful原則に従っていない場合：
  - 「エンドポイント設計がRESTful原則に従っていません。以下の問題があります：[詳細]」
  - 修正提案を提示

- 認証方式が曖昧な場合：
  - 「認証方式が曖昧です。セキュリティリスクがあります。具体的な認証フロー、トークン有効期限、権限管理を明確にしてください。」

- エラーレスポンス形式が統一されていない場合：
  - 「エラーレスポンス形式が統一されていません。フロントエンドでのエラーハンドリングが複雑になります。統一した形式を定義してください。」

- HTTPステータスコードの使い方が不適切な場合：
  - 「HTTPステータスコードの使い方が不適切です。例：」
    - すべて200を返す（エラーも200）→ 適切なステータスコードを使用
    - 認証エラーで403を返す → 401を使用
    - バリデーションエラーで500を返す → 400を使用

- エンドポイント数が非常に多い（100個以上）場合：
  - 「エンドポイント数が多すぎます（X個）。まずはMVPに必要なエンドポイントに絞り、段階的に追加することを推奨します。」

- GraphQL を選択しているのにRESTfulエンドポイントを定義している場合：
  - 「APIスタイルとしてGraphQLを選択していますが、RESTfulエンドポイントが定義されています。GraphQLスキーマ設計に変更しますか？」

- セキュリティ上の懸念がある場合：
  - 「以下のセキュリティ上の懸念があります：」
    - トークンをlocalStorageに保存（XSSリスク）→ HttpOnly Cookie推奨
    - HTTPで認証情報を送信 → HTTPS必須
    - パスワードを平文で送信 → ハッシュ化またはHTTPS必須
    - CORS設定が緩い → 適切なオリジン制限

- レート制限がない場合：
  - 「レート制限が定義されていません。DDoS攻撃やリソース枯渇のリスクがあります。少なくとも認証エンドポイントにはレート制限を設定することを推奨します。」
