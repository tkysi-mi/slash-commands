---
description: ユーザーストーリーから具体的なGherkinシナリオを作成し、BDD形式で振る舞いを定義するワークフロー
auto_execution_mode: 1
---

# /a-003-CreateScenarios

## 目的

- ユーザーストーリーから具体的なシナリオ（振る舞い）を抽出し、Gherkin形式で記述する。
- Given-When-Then構造で、開発者・QA・ステークホルダーが共通理解できる実行可能なドキュメントを作成する。
- ハッピーパス（正常系）からエラーケース、境界値テストまでを網羅的に定義する。
- 後続のテスト自動化やドメインモデリングの基盤となるシナリオ集を整備する。

## 前提

- `docs/project/01-requirements/05-user-stories.md` が作成されていること（先に `/a-002-InitializeProject` を実行）。
- `docs/project/02-behavior/` ディレクトリが存在すること（存在しない場合は先に `/a-001-SetupDocStructure` を実行）。
- `.windsurf/templates/project/02-behavior/01-scenarios.md` テンプレートが最新状態であること。
- ユーザーが各機能の具体的な動作例を説明できること。

## 手順

### 1. ディレクトリと前提条件の確認

- `docs/project/02-behavior/` ディレクトリの存在を確認：
  ```bash
  ls -la docs/project/02-behavior/ 2>/dev/null || echo "ディレクトリが存在しません"
  ```

- ディレクトリが存在しない場合：
  - ユーザーに通知：「`docs/project/02-behavior/` ディレクトリが見つかりません。先に `/a-001-SetupDocStructure` を実行してください。今すぐ実行しますか？」
  - ユーザーが「はい」と回答した場合：`Call /a-001-SetupDocStructure`
  - 完了後、このワークフローを続行する。

- ユーザーストーリーの確認：
  - `@docs/project/01-requirements/05-user-stories.md` を読み込む。
  - ユーザーストーリーが存在しない場合：
    - 「ユーザーストーリーが見つかりません。先に `/a-002-InitializeProject` を実行して要件定義を作成してください。」と通知し、ワークフローを中断する。

### 2. テンプレート確認

- テンプレートを読み込み、Gherkin形式とベストプラクティスを理解する：
  - `@.windsurf/templates/project/02-behavior/01-scenarios.md`

### 3. シナリオ対象機能の特定

- ユーザーストーリーを基に、シナリオを作成する機能をリストアップする：
  - 「ユーザーストーリーから、以下の機能が見つかりました：」
  - 各機能を列挙し、ユーザーに確認する。
  - 「これらの機能すべてについてシナリオを作成しますか？優先順位をつけますか？」

- ユーザーの回答に基づき、シナリオ作成対象の機能を決定する。

### 4. 各機能（Feature）のヒアリング

各機能について、以下を**1つずつ順番に**ヒアリングする。

#### Feature情報の収集

- **機能名**: 「この機能の名前は何ですか？（例：ユーザー登録、注文処理、検索機能）」

- **機能の説明**: 「この機能の目的を1-3文で説明してください。」
  - 追加質問例：「なぜこの機能が必要ですか？」「誰が使いますか？」

- **ユーザーストーリー形式の確認**:
  - 「この機能を以下の形式で表現してください：」
    - **As a** (役割): 「誰が」この機能を使いますか？
    - **I want** (機能): 「何を」したいですか？
    - **So that** (価値): 「なぜ」それをしたいですか？

#### Background（共通前提条件）の確認

- 「この機能のすべてのシナリオに共通する前提条件はありますか？」
  - 例：「ユーザーがログインしている」「システムが起動している」「テストデータが準備されている」
- ある場合は、Given ステップとして記録する。

### 5. シナリオの作成

各機能について、以下のプロセスでシナリオを作成する。

#### ハッピーパス（正常系）の作成

- 「最も基本的な成功シナリオを教えてください。理想的な状況で、ユーザーが期待通りに操作した場合の流れです。」

- **シナリオID**: 自動採番（SC-001, SC-002...）

- **シナリオ名**: 「このシナリオを5-10単語で簡潔に表現すると？」
  - 例：「有効なメールアドレスで登録成功」「商品をカートに追加」

- **優先度**: 「このシナリオの優先度は？（High / Medium / Low）」

- **Given（前提条件）**:
  - 「シナリオ開始時のシステムの状態は？」
  - 「ユーザーはどこにいますか？（画面、ページ、状態など）」
  - 具体的な値や状態を確認する。

- **When（アクション）**:
  - 「ユーザーは何をしますか？」
  - **重要**: UIの操作詳細（「ボタンをクリック」）ではなく、ユーザーの意図（「登録を完了する」）を記述。
  - 具体的なデータがある場合は含める（例：「メールアドレス "user@example.com" で登録する」）

- **Then（期待される結果）**:
  - 「何が起こることを期待しますか？」
  - 検証可能な具体的な結果を確認。
  - 複数の結果がある場合は And でつなぐ。
  - 例：「アカウントが作成される」「ウェルカムメールが送信される」「ダッシュボードにリダイレクトされる」

#### エラーケース・異常系の作成

- 「このシナリオで考えられるエラーケースはありますか？」
  - 例：「無効な入力」「権限エラー」「データ不存在」「ネットワークエラー」

- 各エラーケースについて、ハッピーパスと同じ形式でヒアリング：
  - シナリオ名
  - 優先度
  - Given / When / Then

#### 境界値・エッジケースの確認

- 「境界値やエッジケースはありますか？」
  - 例：「最小値・最大値」「空文字」「特殊文字」「大量データ」

- 複数の類似ケースがある場合、Scenario Outline の使用を提案：
  - 「これらのケースは同じ構造で異なるデータですか？Scenario Outline（パラメータ化）を使用すると効率的です。」

#### Scenario Outline（パラメータ化）の作成

Scenario Outline を使用する場合：

- 「パラメータ化したい入力値と期待される結果の組み合わせをリストアップしてください。」
  - 表形式で収集：
    ```
    | 入力値          | 期待される結果               |
    |----------------|---------------------------|
    | user@example.com | 成功                    |
    | invalid-email   | "無効なメールアドレスです" |
    | @example.com    | "無効なメールアドレスです" |
    ```

- 「この表を意味的にグループ化できますか？（例：正常系 / 異常系）」

### 6. タグの追加

各シナリオにタグを付与：

- **@SC-XXX**: シナリオIDタグ（自動付与）
- **カテゴリタグ**:
  - 「このシナリオにタグを付けますか？」
  - 推奨タグ：
    - `@smoke`: スモークテスト（重要な基本機能）
    - `@regression`: リグレッションテスト
    - `@happy-path`: 正常系
    - `@error-handling`: エラーハンドリング
    - `@validation`: バリデーション
    - `@slow`: 実行時間が長いテスト

### 7. 次の機能へ

- すべての機能について手順4-6を繰り返す。

### 8. シナリオ一覧テーブルの作成

- すべてのシナリオを一覧表にまとめる：
  ```markdown
  | シナリオID | 機能 | シナリオ名 | 優先度 |
  |-----------|------|-----------|--------|
  | SC-001 | ユーザー登録 | 有効なメールアドレスで登録成功 | High |
  | SC-002 | ユーザー登録 | 無効なメールアドレスで登録エラー | High |
  ```

### 9. Gherkin形式のドキュメント作成

- 収集した情報を基に、Gherkin形式でドキュメントを作成する：
  - テンプレートの構造に従う
  - **HTMLコメント（`<!-- ... -->`）は削除せず残す**
  - Feature単位でセクション化
  - 各Scenarioに適切なタグを付与
  - コードブロックは ```gherkin で囲む

- **ベストプラクティスの遵守**:
  - 宣言的スタイル（What）で記述、実装詳細（How）は避ける
  - 具体的な値を使用（抽象的な表現を避ける）
  - ユーザー視点で記述（技術用語を避ける）

### 10. レビューと確認

- 作成したシナリオをユーザーに提示し、以下を確認：
  - 「シナリオは実際の動作を正しく表現していますか？」
  - 「漏れているケースはありませんか？」
  - 「Given-When-Thenの流れは自然ですか？」
  - 「非技術者（ステークホルダー）が読んで理解できますか？」

- フィードバックを反映し、ドキュメントを更新する。

### 11. 完成とコミット準備

- 完成したドキュメントを `docs/project/02-behavior/01-scenarios.md` として保存。

- ユーザーに最終確認を依頼：
  - 「シナリオドキュメントが完成しました。内容を確認してください。」
  - 作成されたシナリオの統計を表示：
    - 機能数
    - シナリオ総数
    - 優先度別の内訳（High / Medium / Low）

- Git コミット・PR作成の準備が整ったことを通知する。

## 完了条件

- `docs/project/02-behavior/01-scenarios.md` が作成されている。
- シナリオ一覧テーブルにすべてのシナリオが記載されている。
- 各機能（Feature）がGherkin形式で記述されている：
  - Feature名、説明、ユーザーストーリー（As a / I want / So that）が記載
  - Background（該当する場合）が記載
  - 各Scenarioに Given-When-Then が明確に記述
  - シナリオIDタグ（@SC-XXX）が付与
  - 適切なカテゴリタグが付与
- ハッピーパス（正常系）とエラーケース（異常系）が網羅されている。
- Scenario Outline（パラメータ化）が適切に使用されている（該当する場合）。
- すべてのシナリオが宣言的スタイルで記述され、実装詳細から独立している。
- 非技術者が読んで理解できる平易な言葉で記述されている。
- ユーザーがドキュメント内容を確認し、承認している。

## エスカレーション

- ユーザーストーリーが不明確で具体的なシナリオを作成できない場合：
  - 「ユーザーストーリーが抽象的すぎて、具体的なシナリオを作成できません。先に `/a-002-InitializeProject` でユーザーストーリーを詳細化してください。」と通知し、ワークフローを中断する。

- ユーザーがGiven-When-Thenの区別を理解できない場合：
  - 具体例を示して説明する：
    ```
    Given ユーザーが登録ページにいる（前提条件：初期状態）
    When メールアドレス "user@example.com" で登録する（アクション：何をする）
    Then アカウントが作成される（期待結果：何が起こる）
    ```

- シナリオが技術的すぎる、または実装詳細に依存している場合：
  - 「このシナリオは実装詳細に依存しています。ユーザーの意図に焦点を当てた宣言的な表現に変更しましょう。」と提案し、リファクタリングを支援する。
  - 例：
    - ❌ `When "登録"ボタンをクリックし、"OK"ボタンをクリックする`
    - ✅ `When 登録を完了する`

- シナリオが膨大で管理が困難になる場合：
  - 「シナリオ数が多すぎます。優先度の高いシナリオから作成し、残りは後続のスプリントで追加することを推奨します。」と提案する。

- 複数機能間の依存関係が複雑な場合：
  - 「機能間の依存が複雑です。各シナリオは独立して実行可能にする必要があります。依存を解消するか、Background で共通の前提条件を設定しましょう。」と助言する。
