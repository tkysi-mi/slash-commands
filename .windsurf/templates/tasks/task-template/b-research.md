# リサーチドキュメント

<!--
このドキュメントについて:
  - 格納場所: docs/tasks/task000001-{スラッグ}/b-research.md
  - 作成方法: /b-002-CreateTaskResearch ワークフローで作成
  - 前提条件: a-definition.md が作成済みであること
  - 関連ドキュメント:
    - a-definition.md (タスク定義ドキュメント)
    - c-implementation.md (実装タスクリスト)

このドキュメントの目的:
  - 実装前の技術調査結果を記録
  - ベストプラクティスの収集と共有
  - 既存コードの再利用可能性を確認
  - 技術的なリスクや制約の洗い出し

更新タイミング:
  - タスク実装前の調査段階で作成
  - 新しい知見が得られた時に追記
  - レビュー時の指摘を反映
-->

---

## 1. ベストプラクティス

<!--
何を書くか: 実装に関連する技術的なベストプラクティス

記載のポイント:
  - 公式ドキュメントの推奨事項
  - 業界標準やコミュニティのコンセンサス
  - パフォーマンス、セキュリティ、保守性の観点
  - アンチパターンとその理由

情報源:
  - 公式ドキュメント（React, Next.js, etc.）
  - GitHub の人気リポジトリ（類似機能の実装例）
  - Stack Overflow、Qiita、Zenn などの技術記事
  - チーム内の過去の実装事例

ベストプラクティス:
  - 単なる個人の意見ではなく、根拠のある情報を記載
  - リンクを必ず含める（情報の鮮度確認のため）
  - 複数の選択肢がある場合は比較表を作成
  - このプロジェクトに適用できない場合はその理由も記載
-->

| トピック | ベストプラクティス | 参考リンク |
|---------|-------------------|-----------|
| <!-- 例: フォームバリデーション --> | <!-- 例: React Hook Form + Zod を使用。パフォーマンスが良く、型安全性が高い --> | <!-- 例: [React Hook Form 公式](https://react-hook-form.com/) --> |
| <!-- 例: メール送信 --> | <!-- 例: SendGrid や Resend などのサービスを利用。自前 SMTP は避ける --> | <!-- 例: [Resend Best Practices](https://resend.com/docs) --> |

---

## 2. 既存コードの調査

<!--
何を書くか: このプロジェクト内の既存実装を調査

調査対象:
  - 類似機能の実装（同じパターンで実装可能か）
  - 共通ライブラリやユーティリティ（車輪の再発明を避ける）
  - アーキテクチャパターン（プロジェクトの慣習に従う）
  - データモデルや API 設計（既存のパターンを踏襲）

記載のポイント:
  - ファイルパスを正確に記載（Read や Grep で確認）
  - コードスニペットを含める（重要な部分のみ）
  - なぜそのコードを参考にすべきか理由を記載
  - 改善すべき点があれば指摘

ベストプラクティス:
  - 単にコードをコピペするのではなく、設計意図を理解する
  - 依存関係や副作用を確認
  - テストコードも参考にする（期待される振る舞いを理解）
  - 最新のコードか確認（古い実装を参考にしない）
-->

| 項目 | 内容 |
|------|------|
| 類似機能のファイルパス | <!-- 例: src/features/auth/PasswordResetForm.tsx (メール送信フロー) --> |
| 実装パターン | <!-- 例: React Hook Form でフォーム管理、API 呼び出しは useMutation で非同期処理 --> |
| 参考にすべき点 | <!-- 例: エラーハンドリングのパターン、ローディング状態の管理、ユーザーへのフィードバック表示 --> |

---

## 3. 再利用可能なコンポーネント

<!--
何を書くか: 既存の共通コンポーネントやライブラリで再利用できるもの

調査対象:
  - UI コンポーネント（Button, Input, Modal など）
  - カスタムフック（useAuth, useFetch など）
  - ユーティリティ関数（formatDate, validateEmail など）
  - API クライアント、データフェッチャー

記載のポイント:
  - コンポーネント名とファイルパス
  - 使用方法（Props、引数、戻り値）
  - 使用例（簡単なコードスニペット）
  - 制約事項や注意点

ベストプラクティス:
  - 実際にコードを読んで Props や型を確認
  - 他の箇所での使用例を探す（実践的な使い方を学ぶ）
  - Storybook やドキュメントがあれば参照
  - 古いコンポーネントの場合、リファクタリング検討
-->

| コンポーネント名 | ファイルパス | 使用方法 |
|-----------------|-------------|----------|
| `Button` | `src/components/Button.tsx` | `<Button variant="primary" onClick={handleClick}>送信</Button>` |
| `useToast` | `src/hooks/useToast.ts` | `const { showToast } = useToast(); showToast({ message: "成功", type: "success" });` |
| `apiClient` | `src/lib/apiClient.ts` | `await apiClient.post("/api/auth/verify", { token });` |

---

## 4. 技術選定

<!--
何を書くか: このタスクで使用する技術やライブラリの選定理由（必要に応じて）

記載のポイント:
  - 複数の選択肢がある場合の比較
  - 選定基準（パフォーマンス、型安全性、コミュニティサポート、学習コスト）
  - 選定した技術のメリット・デメリット
  - 既存プロジェクトとの整合性

ベストプラクティス:
  - 感覚ではなくデータに基づいて選定（npm trends、GitHub スター数、メンテナンス状況）
  - チーム内で合意を取る（新しいライブラリ導入は慎重に）
  - ライセンスを確認（商用利用可能か）
  - バンドルサイズを考慮（フロントエンドの場合）
-->

| 技術・ライブラリ | 選定理由 | 代替案との比較 |
|----------------|---------|---------------|
| <!-- 例: Zod --> | <!-- 例: TypeScript の型定義からバリデーションスキーマを自動生成可能。React Hook Form との統合が容易 --> | <!-- 例: Yup は型推論が弱い。Joi はバンドルサイズが大きい --> |

---

## 5. 技術的リスクと制約

<!--
何を書くか: 実装時に想定される技術的な課題やリスク

記載すべき内容:
  - パフォーマンス上の懸念（大量データ、重い処理）
  - セキュリティリスク（XSS, CSRF, SQL Injection など）
  - ブラウザ互換性の問題
  - 外部サービスへの依存（API の制限、障害時の影響）
  - スケーラビリティの課題

ベストプラクティス:
  - リスクだけでなく軽減策も記載
  - 優先度をつける（高/中/低）
  - 実装前にチームで共有して合意を取る
-->

| リスク | 影響 | 軽減策 |
|--------|------|--------|
| <!-- 例: メール送信の遅延 --> | <!-- 例: ユーザー登録完了までに時間がかかる --> | <!-- 例: 非同期ジョブキューで処理。即座に「メール送信中」メッセージを表示 --> |

---

## メモ

<!--
リサーチ全体に関する補足情報

記載すべき内容:
  - 調査中に気づいた改善点
  - 今後の調査が必要な項目
  - 参考になった記事や動画
  - チームメンバーへの質問事項
  - 調査の過程で発見した技術的負債

例:
- 既存のメール送信機能が古い実装のため、リファクタリング検討
- パフォーマンステストが必要（大量ユーザー登録時の負荷）
- セキュリティレビューをチームリーダーに依頼
-->
